<div class="molecule-container">
  <div class="canvas-container">
    {% assign unique_id = include.id | default: 'mol' %}
    {% unless include.id %}
      {% assign content_hash = include.xyz | append: include.mol | append: include.smiles | append: include.representation | append: include.bgcolor | size %}
      {% assign unique_id = unique_id | append: '_' | append: content_hash | append: '_' | append: include.mode %}
    {% endunless %}
    
    {% if include.mode == '2d' %}
      <canvas id="viewACS_{{ unique_id }}" width="{{ include.width | default: 400 }}" height="{{ include.height | default: 300 }}"></canvas>
    {% elsif include.mode == '3d' %}
      <canvas id="transform3d_{{ unique_id }}" width="{{ include.width | default: 400 }}" height="{{ include.height | default: 400 }}"></canvas>
    {% endif %}
  </div>
</div>

<script>
function normalizeMolBlock(rawMol) {
  if (!rawMol) return '';
  return String(rawMol).replace(/\r\n?/g, '\n').trim();
}

function parseMolWithFallback(rawMol) {
  var molData = normalizeMolBlock(rawMol);
  if (!molData) return null;

  var molecule = ChemDoodle.readMOL(molData);
  if (molecule && molecule.atoms && molecule.atoms.length > 0) {
    return molecule;
  }

  var lines = molData.split('\n');
  var countsIndex = -1;
  for (var i = 0; i < lines.length; i++) {
    if (/^\s*\d+\s+\d+/.test(lines[i])) {
      countsIndex = i;
      break;
    }
  }

  if (countsIndex === -1) {
    return null;
  }

  var counts = lines[countsIndex].trim().split(/\s+/);
  var atomCount = parseInt(counts[0], 10);
  var bondCount = parseInt(counts[1], 10);
  if (!Number.isInteger(atomCount) || !Number.isInteger(bondCount) || atomCount <= 0 || bondCount < 0) {
    return null;
  }

  var parsed = new ChemDoodle.structures.Molecule();

  for (var a = 0; a < atomCount; a++) {
    var atomLine = lines[countsIndex + 1 + a];
    if (!atomLine) return null;

    var atomParts = atomLine.trim().split(/\s+/);
    if (atomParts.length < 4) return null;

    var x = parseFloat(atomParts[0]);
    var y = parseFloat(atomParts[1]);
    var z = parseFloat(atomParts[2]);
    var element = atomParts[3];

    if (!Number.isFinite(x) || !Number.isFinite(y) || !Number.isFinite(z) || !element) {
      return null;
    }

    parsed.atoms.push(new ChemDoodle.structures.Atom(element, x, y, z));
  }

  for (var b = 0; b < bondCount; b++) {
    var bondLine = lines[countsIndex + 1 + atomCount + b];
    if (!bondLine) return null;

    var bondParts = bondLine.trim().split(/\s+/);
    if (bondParts.length < 3) return null;

    var beginIndex = parseInt(bondParts[0], 10) - 1;
    var endIndex = parseInt(bondParts[1], 10) - 1;
    var order = parseInt(bondParts[2], 10);

    if (!parsed.atoms[beginIndex] || !parsed.atoms[endIndex]) {
      return null;
    }

    parsed.bonds.push(new ChemDoodle.structures.Bond(parsed.atoms[beginIndex], parsed.atoms[endIndex], Number.isInteger(order) ? order : 1));
  }

  return parsed.atoms.length > 0 ? parsed : null;
}

{% if include.mode == '2d' %}
/* 2D Canvas */
(function() {
  /* Generate truly unique ID at runtime */
  var timestamp = Date.now();
  var random = Math.floor(Math.random() * 10000);
  var uniqueCanvasId = 'view2d_' + timestamp + '_' + random;
  
  /* Update the canvas element ID */
  var originalCanvas = document.getElementById('viewACS_{{ unique_id }}');
  if (originalCanvas) {
    originalCanvas.id = uniqueCanvasId;
    console.log('Canvas ID updated from viewACS_{{ unique_id }} to:', uniqueCanvasId);
  } else {
    console.error('Original canvas not found: viewACS_{{ unique_id }}');
    return;
  }
  
  var canvas = new ChemDoodle.ViewerCanvas(uniqueCanvasId, {{ include.width | default: 400 }}, {{ include.height | default: 300 }});
  canvas.styles.bonds_width_2D = 0.6;
  canvas.styles.bonds_saturationWidthAbs_2D = 2.6;
  canvas.styles.atoms_font_size_2D = 10;
  
  {% if include.smiles %}
  var smiles = '{{ include.smiles }}';
  var molfile = OCL.Molecule.fromSmiles(smiles).toMolfile();
  var molecule = ChemDoodle.readMOL(molfile);
  molecule.scaleToAverageBondLength({{ include.scale | default: 20 }});
  canvas.loadMolecule(molecule);
  {% elsif include.mol %}
  var molData = {{ include.mol | jsonify }};
  var molecule = parseMolWithFallback(molData);
  if (molecule && molecule.atoms && molecule.atoms.length > 0) {
    molecule.scaleToAverageBondLength({{ include.scale | default: 20 }});
    canvas.loadMolecule(molecule);
  } else {
    console.error('Failed to parse MOL data for:', uniqueCanvasId, molData);
  }
  {% endif %}
})();

{% elsif include.mode == '3d' %}
/* 3D Canvas */
(function() {
  /* Generate truly unique ID at runtime */
  var timestamp = Date.now();
  var random = Math.floor(Math.random() * 10000);
  var uniqueCanvasId = 'transform3d_' + timestamp + '_' + random;
  
  /* Update the canvas element ID */
  var originalCanvas = document.getElementById('transform3d_{{ unique_id }}');
  if (originalCanvas) {
    originalCanvas.id = uniqueCanvasId;
    console.log('Canvas ID updated from transform3d_{{ unique_id }} to:', uniqueCanvasId);
  } else {
    console.error('Original canvas not found: transform3d_{{ unique_id }}');
    return;
  }
  
  console.log('Starting 3D canvas initialization for:', uniqueCanvasId);
  var canvas = new ChemDoodle.TransformCanvas3D(uniqueCanvasId, {{ include.width | default: 400 }}, {{ include.height | default: 400 }});
  console.log('3D canvas created:', uniqueCanvasId);
  
  canvas.styles.set3DRepresentation('{{ include.representation | default: "Ball and Stick" }}');
  canvas.styles.backgroundColor = '{{ include.bgcolor | default: "black" }}';
  canvas.styles.atoms_useVDWDiameters_3D = {{ include.use_vdw_3d | default: false }};
  canvas.styles.atoms_vdwMultiplier_3D = {{ include.vdw_multiplier_3d | default: 1.0 }};
  canvas.styles.atoms_sphereDiameter_3D = {{ include.atom_diameter_3d | default: 1.2 }};
  canvas.styles.bonds_cylinderDiameter_3D = {{ include.bond_diameter_3d | default: 0.3 }};
  console.log('Styles set for:', uniqueCanvasId);
  
  {% if include.xyz %}
  /* Parse XYZ coordinate data */
  var xyzData = {{ include.xyz | jsonify }};
  var lines = xyzData.trim().split('\n');
  var numAtoms = parseInt(lines[0]);
  var comment = lines[1]; /* Skip comment line */
  
  var molecule = new ChemDoodle.structures.Molecule();
  
  function normalizeElementSymbol(rawSymbol) {
    if (!rawSymbol) return null;

    var lettersOnly = rawSymbol.replace(/[^A-Za-z]/g, '');
    if (!lettersOnly) return null;

    var normalized = lettersOnly.charAt(0).toUpperCase() + lettersOnly.slice(1).toLowerCase();
    if (ChemDoodle.ELEMENT && ChemDoodle.ELEMENT[normalized]) {
      return normalized;
    }

    return null;
  }

  /* Parse atoms from XYZ data */
  for (var i = 2; i < 2 + numAtoms && i < lines.length; i++) {
    var parts = lines[i].trim().split(/\s+/);
    if (parts.length < 4) {
      console.warn('Skipping malformed XYZ line at index', i, ':', lines[i]);
      continue;
    }

    var element = normalizeElementSymbol(parts[0]);
    var x = parseFloat(parts[1]);
    var y = parseFloat(parts[2]);
    var z = parseFloat(parts[3]);

    if (!element || !Number.isFinite(x) || !Number.isFinite(y) || !Number.isFinite(z)) {
      console.warn('Skipping invalid atom entry at line', i, ':', lines[i]);
      continue;
    }

    molecule.atoms.push(new ChemDoodle.structures.Atom(element, x, y, z));
  }
  
  /* Auto-generate bonds based on distance (simple approach) */
  /* You may want to customize this based on your needs */
  for (var j = 0; j < molecule.atoms.length; j++) {
    for (var k = j + 1; k < molecule.atoms.length; k++) {
      var atom1 = molecule.atoms[j];
      var atom2 = molecule.atoms[k];
      
      var dx = atom1.x - atom2.x;
      var dy = atom1.y - atom2.y;
      var dz = atom1.z - atom2.z;
      var distance = Math.sqrt(dx*dx + dy*dy + dz*dz);
      
      /* Simple bonding criteria based on atomic radii */
      var maxBondDistance = 2.0; /* Adjust as needed */
      if (distance < maxBondDistance) {
        molecule.bonds.push(new ChemDoodle.structures.Bond(atom1, atom2));
      }
    }
  }
  
  console.log('XYZ molecule created for', uniqueCanvasId, 'with', molecule.atoms.length, 'atoms and', molecule.bonds.length, 'bonds');
  canvas.loadMolecule(molecule);
  console.log('XYZ molecule loaded for:', uniqueCanvasId);
  {% elsif include.mol %}
  var molData = {{ include.mol | jsonify }};
  var molecule = parseMolWithFallback(molData);
  if (molecule && molecule.atoms && molecule.atoms.length > 0) {
    console.log('MOL molecule created for', uniqueCanvasId, 'with', molecule.atoms.length, 'atoms');
    canvas.loadMolecule(molecule);
    console.log('MOL molecule loaded for:', uniqueCanvasId);
  } else {
    console.error('Failed to parse MOL data for:', uniqueCanvasId, molData);
  }
  {% elsif include.smiles %}
  var smiles = '{{ include.smiles }}';
  var molfile = OCL.Molecule.fromSmiles(smiles).toMolfile();
  var molecule = ChemDoodle.readMOL(molfile);
  console.log('SMILES molecule created for', uniqueCanvasId, 'with', molecule.atoms.length, 'atoms');
  canvas.loadMolecule(molecule);
  console.log('SMILES molecule loaded for:', uniqueCanvasId);
  {% endif %}
})();
{% endif %}
</script>

<style>
  .molecule-container {
    text-align: center;
    margin: 20px 0;
  }
  
  .canvas-container {
    display: inline-block;
    border: 1px solid #ddd;
    border-radius: 4px;
  }
</style>
